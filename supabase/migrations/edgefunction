// supabase/functions/admin-users/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

type Action =
  | "create_user"
  | "invite_user"
  | "reset_password"
  | "set_user_enabled"
  | "grant_access"
  | "revoke_access";

function json(status: number, body: unknown) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string) {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env: ${name}`);
  return v;
}

serve(async (req) => {
  try {
    if (req.method !== "POST") return json(405, { error: "Method not allowed" });

    // 1) Setup clients
    const SUPABASE_URL = requireEnv("SUPABASE_URL");
    const ANON_KEY = requireEnv("SUPABASE_ANON_KEY");
    const SERVICE_ROLE = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const authHeader = req.headers.get("authorization") || "";
    const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : null;
    if (!token) return json(401, { error: "Missing bearer token" });

    // Client para validar usuário chamador (usa ANON + JWT)
    const userClient = createClient(SUPABASE_URL, ANON_KEY, {
      global: { headers: { Authorization: `Bearer ${token}` } },
    });

    const { data: userData, error: userErr } = await userClient.auth.getUser();
    if (userErr || !userData?.user) return json(401, { error: "Unauthorized" });

    const actorUserId = userData.user.id;

    // Client admin (service role) — NUNCA expor no front
    const adminClient = createClient(SUPABASE_URL, SERVICE_ROLE);

    // 2) Check platform admin
    const { data: adminRow, error: adminCheckErr } = await adminClient
      .from("platform_admin_profiles")
      .select("user_id")
      .eq("user_id", actorUserId)
      .maybeSingle();

    if (adminCheckErr) return json(500, { error: "Admin check failed", details: adminCheckErr.message });
    if (!adminRow?.user_id) return json(403, { error: "Forbidden" });

    // 3) Parse payload
    const payload = await req.json();
    const action: Action = payload?.action;

    if (!action) return json(400, { error: "Missing action" });

    // Helpers
    const log = async (entry: any) => {
      await adminClient.from("admin_audit_log").insert({
        actor_user_id: actorUserId,
        action,
        target_user_id: entry?.target_user_id ?? null,
        target_store_id: entry?.target_store_id ?? null,
        payload: entry?.payload ?? payload ?? null,
      });
    };

    // ===== ACTIONS =====

    if (action === "create_user" || action === "invite_user") {
      const email = String(payload.email || "").trim().toLowerCase();
      const full_name = String(payload.full_name || "").trim();
      const store_id = payload.store_id ? String(payload.store_id) : null;
      const role_id = payload.role_id ? String(payload.role_id) : null;
      const password = payload.password ? String(payload.password) : null;

      if (!email) return json(400, { error: "email is required" });
      if (!store_id || !role_id) return json(400, { error: "store_id and role_id are required" });

      // garante store e role existem
      const { data: storeOk } = await adminClient.from("stores").select("id").eq("id", store_id).maybeSingle();
      if (!storeOk?.id) return json(400, { error: "Invalid store_id" });

      const { data: roleOk } = await adminClient.from("store_roles").select("id").eq("id", role_id).maybeSingle();
      if (!roleOk?.id) return json(400, { error: "Invalid role_id" });

      // cria ou convida
      let createdUserId: string | null = null;

      if (action === "invite_user") {
        // convite por email
        const { data, error } = await adminClient.auth.admin.inviteUserByEmail(email, {
          data: { full_name },
        });
        if (error) return json(400, { error: error.message });
        createdUserId = data.user?.id ?? null;
      } else {
        // create_user: se não vier senha, cria sem (pode forçar reset depois)
        const { data, error } = await adminClient.auth.admin.createUser({
          email,
          password: password ?? undefined,
          email_confirm: false,
          user_metadata: { full_name },
        });
        if (error) return json(400, { error: error.message });
        createdUserId = data.user?.id ?? null;
      }

      if (!createdUserId) return json(500, { error: "Could not create user" });

      // upsert profile
      await adminClient.from("store_user_profiles").upsert({
        user_id: createdUserId,
        full_name,
        email,
      }, { onConflict: "user_id" });

      // grant store access (upsert)
      await adminClient.from("user_store_access").upsert({
        user_id: createdUserId,
        store_id,
        role: role_id,
      }, { onConflict: "user_id,store_id" });

      await log({ target_user_id: createdUserId, target_store_id: store_id });

      return json(200, { ok: true, user_id: createdUserId, store_id, role_id });
    }

    if (action === "reset_password") {
      const user_id = String(payload.user_id || "");
      const email = payload.email ? String(payload.email).trim().toLowerCase() : null;
      const redirect_to = payload.redirect_to ? String(payload.redirect_to) : null;

      if (!user_id && !email) return json(400, { error: "user_id or email is required" });

      // generate recovery link (melhor para admin: retorna link e você decide enviar)
      const { data, error } = await adminClient.auth.admin.generateLink({
        type: "recovery",
        email: email ?? "",
        user_id: user_id || undefined,
        options: redirect_to ? { redirectTo: redirect_to } : undefined,
      });

      if (error) return json(400, { error: error.message });

      await log({ target_user_id: data?.user?.id ?? user_id ?? null });

      return json(200, { ok: true, action: "reset_password", link: data?.properties?.action_link ?? null });
    }

    if (action === "set_user_enabled") {
      const user_id = String(payload.user_id || "");
      const enabled = Boolean(payload.enabled);

      if (!user_id) return json(400, { error: "user_id is required" });

      // Disable: banned_until no futuro (ex: 100 anos). Enable: null
      const banned_until = enabled ? null : "2125-01-01T00:00:00Z";

      const { data, error } = await adminClient.auth.admin.updateUserById(user_id, {
        banned_until,
      });

      if (error) return json(400, { error: error.message });

      await log({ target_user_id: user_id, payload: { enabled } });

      return json(200, { ok: true, user_id: data.user?.id ?? user_id, enabled });
    }

    if (action === "grant_access") {
      const user_id = String(payload.user_id || "");
      const store_id = String(payload.store_id || "");
      const role_id = String(payload.role_id || "");

      if (!user_id || !store_id || !role_id) return json(400, { error: "user_id, store_id, role_id required" });

      await adminClient.from("user_store_access").upsert(
        { user_id, store_id, role: role_id },
        { onConflict: "user_id,store_id" },
      );

      await log({ target_user_id: user_id, target_store_id: store_id });

      return json(200, { ok: true });
    }

    if (action === "revoke_access") {
      const user_id = String(payload.user_id || "");
      const store_id = String(payload.store_id || "");

      if (!user_id || !store_id) return json(400, { error: "user_id and store_id required" });

      await adminClient.from("user_store_access").delete().eq("user_id", user_id).eq("store_id", store_id);

      await log({ target_user_id: user_id, target_store_id: store_id });

      return json(200, { ok: true });
    }

    return json(400, { error: "Unknown action" });
  } catch (e) {
    return json(500, { error: "Internal error", details: String(e?.message ?? e) });
  }
});
